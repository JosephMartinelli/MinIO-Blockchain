"""Much of the code has been taken from this wonderful tutorial
https://gist.github.com/satwikkansal/4a857cad2797b9d199547a752933a715
and the following video
https://www.bing.com/videos/riverview/relatedvideo?q=python+api+for+blockchain&mid=7ABED193A02AE8493E617ABED193A02AE8493E61&FORM=VIRE
"""

from datetime import datetime
import json
import hashlib


class Block:
    def __init__(
        self,
        index: int,
        transactions: list[dict],
        timestamp: datetime | str,
        previous_hash: str,
        proof: int = 0
    ):
        self.index = index
        self.transactions = transactions
        if isinstance(timestamp,datetime):
            self.timestamp = timestamp.strftime("%d/%m/%y %H:%M:%S.%f")
        else:
            self.timestamp = timestamp
        self.previous_hash = previous_hash
        self.proof = proof

    def compute_hash(self):
        return hashlib.sha256(
            json.dumps(self.__dict__, sort_keys=True).encode()
        ).hexdigest()

    def __str__(self):
        return str(self.__dict__)


class BlockChain:
    def __init__(self, difficulty: int,genesis_block: Block = None):
        self.chain: [Block] = []
        if genesis_block:
            self.chain.append(genesis_block)
        else:
            self.create_genesis_block()
        self.difficulty = difficulty  # This is the difficulty of the PoW algorithm into the calculating the nonce
        self.unconfirmed_transactions = (
            []
        )  # Pool of transaction that need to be validated (or mined)

    def create_genesis_block(self):
        genesis_block = Block(0, [], datetime.now(), "0")
        genesis_block.previous_hash = 0
        self.chain.append(genesis_block)

    def digest_proof_and_transactions(
        self, previous_proof: int, next_proof: int, index: int, transactions: []
    ) -> bytes:
        math_proof = str(previous_proof**2 - next_proof**2 + index).encode()
        transaction_data = json.dumps(transactions).encode()
        return math_proof + transaction_data

    def proof_of_work(self, block_to_calculate_proof: Block):
        """
        This function tries different values of the proof and finds a suitable value that satisfies the difficulty
        set by the blockchain. The nonce is then stored in the block
        :return:
        """
        previous_proof = self.get_last_bloc.proof
        current_index = len(self.chain)
        while True:
            digested_data = self.digest_proof_and_transactions(
                previous_proof=previous_proof,
                next_proof=block_to_calculate_proof.proof,
                index=current_index,
                transactions=block_to_calculate_proof.transactions,
            )
            computed_hash = hashlib.sha256(digested_data).hexdigest()
            if computed_hash.startswith("0" * self.difficulty):
                break
            block_to_calculate_proof.proof += 1

    def mine(self):
        """
        This function adds pending transactions to a block and figures
        out the proof of work
        :return:
        """
        # This is the case no transaction is available
        if not self.unconfirmed_transactions:
            return False

        last_hash = self.get_last_bloc.compute_hash()
        index = self.get_last_bloc.index + 1

        new_block = Block(
            index=index,
            transactions=self.unconfirmed_transactions,
            timestamp=datetime.now(),
            previous_hash=last_hash,
        )
        self.proof_of_work(new_block)
        self.chain.append(new_block)
        self.unconfirmed_transactions = []
        return f"Block #{new_block.index} has been mined!"

    def add_new_transaction(self, transactions: list[list | dict]):
        self.unconfirmed_transactions.append(transactions)

    @property
    def get_last_bloc(self) -> Block:
        return self.chain[-1]

    def is_chain_valid(self) -> bool:
        """
        This function checks each block's hash of the chain with the field 'previous_hash' of the block immediately next
        to it. If there is a mismatch, then it means that the transactions have been altered and the chain is no longer
        valid.
        :return:
        """
        for i in range(len(self.chain) - 1):
            current_block: Block = self.chain[i]
            next_block: Block = self.chain[i + 1]
            # This checks that the hash the block is referring to is valid
            if next_block.previous_hash != current_block.compute_hash():
                return False
            # Then we check that the proof of work generated by the block respects the complexity of the blockchain
            # This is the digested data of the next block
            digested_data = self.digest_proof_and_transactions(
                next_proof=next_block.proof,
                previous_proof=current_block.proof,
                transactions=next_block.transactions,
                index=next_block.index,
            )
            block_hash = hashlib.sha256(digested_data).hexdigest()
            if block_hash.startswith("0" * self.difficulty):
                return True
            else:
                print(
                    f"Block {next_block.__dict__} has been rejected due to an hash alteration: ",
                    block_hash,
                )
                return False
        return True

    def add_block(self,new_block: Block):
        last_block = self.get_last_bloc
        if new_block.index != (last_block.index + 1):
            raise IndexError(f"Current index is {last_block.index}, but the index passed is {new_block.index}")
        if last_block.compute_hash() != new_block.previous_hash:
            print(last_block.compute_hash(),"\n",new_block.previous_hash)
            raise ValueError("The passed hash is not consistent with the hash of the last block")
        digested_data = self.digest_proof_and_transactions(
            next_proof=new_block.proof,
            previous_proof=last_block.proof,
            transactions=new_block.transactions,
            index=new_block.index,
        )
        block_hash = hashlib.sha256(digested_data).hexdigest()
        if not block_hash.startswith("0" * self.difficulty):
            raise ValueError("Block hash is not consistent with chain difficulty")
        self.chain.append(new_block)


